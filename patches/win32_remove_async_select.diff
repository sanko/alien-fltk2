diff -ur fltk-2.0.x-r7725.orig/src/win32/run.cxx fltk-2.0.x-r7725/src/win32/run.cxx
--- fltk-2.0.x-r7725.orig/src/win32/run.cxx	Tue Sep 07 19:16:42 2010
+++ fltk-2.0.x-r7725/src/win32/run.cxx	Mon Jan 10 11:56:37 2011
@@ -85,10 +85,25 @@
 #endif
-
-//
-// USE_ASYNC_SELECT - define it non-zero if you have WSAAsyncSelect()...
-//
-#define USE_ASYNC_SELECT 1
-
-// USE_IMM - define it non-zero if you want Input Method
-#define USE_IMM 1
+//
+// USE_ASYNC_SELECT - define it non-zero if you have WSAAsyncSelect()...
+// USE_ASYNC_SELECT is OBSOLETED in 1.3 for the following reasons:
+/*
+  This feature was supposed to provide an efficient alternative to the current
+  polling method, but as it has been discussed (Thanks Albrecht!) :
+  - the async mode would imply to change the socket to non blocking mode.
+    This can have unexpected side effects for 3rd party apps, especially
+    if it is set on-the-fly when socket service is really needed, as it is 
+    done today and on purpose, but still the 3rd party developer wouldn't easily
+    control the sequencing of socket operations.
+  - Finer granularity of events furthered by the async select is a plus only 
+    for socket 3rd party impl., it is simply not needed for the 'light' fltk
+    use we make of wsock, so here it would also be a bad point, because of all
+    the logic add-ons necessary for using this functionality, without a clear
+    benefit.
+
+  So async mode select would not add benefits to fltk, worse, it can slowdown
+  fltk because of this finer granularity and instrumentation code to be added
+  for async mode proper operation, not mentioning the side effects...
+*/
+// USE_IMM - define it non-zero if you want Input Method
+#define USE_IMM 1
 
@@ -273,11 +288,8 @@
 // Microsoft provides the Berkeley select() call and an asynchronous
-// select function that sends a _WIN32 message when the select condition
-// exists...
-
-#ifndef USE_ASYNC_SELECT
-static fd_set fdsets[3];
-#endif // !USE_ASYNC_SELECT
-
-#define POLLIN 1
-#define POLLOUT 4
+// select function that sends a _WIN32 message when the select condition
+// exists...
+static fd_set fdsets[3];
+static int maxfd = 0;
+#define POLLIN 1
+#define POLLOUT 4
 #define POLLERR 8
@@ -303,19 +315,10 @@
   fd[i].events = events;
-  fd[i].cb = cb;
-  fd[i].arg = v;
-
-#ifdef USE_ASYNC_SELECT
-  int mask = 0;
-  if (events & POLLIN) mask |= FD_READ;
-  if (events & POLLOUT) mask |= FD_WRITE;
-  if (events & POLLERR) mask |= FD_CLOSE;
-  WSAAsyncSelect(n, 0/*window*/, WM_FLSELECT, mask);
-#else
-  if (events & POLLIN) FD_SET(n, &fdsets[0]);
-  if (events & POLLOUT) FD_SET(n, &fdsets[1]);
-  if (events & POLLERR) FD_SET(n, &fdsets[2]);
-#endif // USE_ASYNC_SELECT
-}
-
-void fltk::add_fd(int fd, FileHandler cb, void* v) {
+  fd[i].cb = cb;
+  fd[i].arg = v;
+  if (events & POLLIN) FD_SET(n, &fdsets[0]);
+  if (events & POLLOUT) FD_SET(n, &fdsets[1]);
+  if (events & POLLERR) FD_SET(n, &fdsets[2]);
+  if (n > maxfd) maxfd = n;
+}
+void fltk::add_fd(int fd, FileHandler cb, void* v) {
   add_fd(fd, POLLIN, cb, v);
@@ -336,15 +339,9 @@
     j++;
-  }
-  nfds = j;
-
-#ifdef USE_ASYNC_SELECT
-  WSAAsyncSelect(n, 0, 0, 0);
-#else
-  if (events & POLLIN) FD_CLR(unsigned(n), &fdsets[0]);
-  if (events & POLLOUT) FD_CLR(unsigned(n), &fdsets[1]);
-  if (events & POLLERR) FD_CLR(unsigned(n), &fdsets[2]);
-#endif // USE_ASYNC_SELECT
-}
-
-// these pointers are set by the lock() function:
+  }
+  nfds = j;
+  if (events & POLLIN) FD_CLR(unsigned(n), &fdsets[0]);
+  if (events & POLLOUT) FD_CLR(unsigned(n), &fdsets[1]);
+  if (events & POLLERR) FD_CLR(unsigned(n), &fdsets[2]);
+}
+// these pointers are set by the lock() function:
 static void nothing() {}
@@ -360,20 +357,14 @@
 
-// ready() is just like wait(0.0) except no callbacks are done:
-static inline int fl_ready() {
-  if (__PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE)) return 1;
-#ifdef USE_ASYNC_SELECT
-  return 0;
-#else
-  timeval t;
-  t.tv_sec = 0;
-  t.tv_usec = 0;
-  fd_set fdt[3];
-  fdt[0] = fdsets[0];
-  fdt[1] = fdsets[1];
-  fdt[2] = fdsets[2];
-  return ::select(0,&fdt[0],&fdt[1],&fdt[2],&t);
-#endif // USE_ASYNC_SELECT
-}
-
-/**
+// ready() is just like wait(0.0) except no callbacks are done:
+static inline int fl_ready() {
+  if (__PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE)) return 1;
+  if (!nfds) return 0;
+  timeval t;
+  t.tv_sec = 0;
+  t.tv_usec = 0;
+  fd_set fdt[3];
+  memcpy(fdt, fdsets, sizeof fdt);
+  return ::select(0,&fdt[0],&fdt[1],&fdt[2],&t);
+}
+/**
 The most recent message read by GetMessage() (which is called by
@@ -390,22 +381,25 @@
 // timeout, and >0 if any callbacks were done.	This version only
-// returns zero if nothing happens during a 0.0 timeout, otherwise
-// it returns 1.
-static inline int fl_wait(double time_to_wait) {
-
-#ifndef USE_ASYNC_SELECT
-  if (nfds) {
-    // For _WIN32 we need to poll for socket input FIRST, since
-    // the event queue is not something we can select() on...
+// returns zero if nothing happens during a 0.0 timeout, otherwise
+// it returns 1.
+static inline int fl_wait(double time_to_wait) {
+  int have_message = 0;
+
+  // idle processing
+  static char in_idle;
+  if (fltk::idle && !in_idle) {
+    in_idle = 1;
+    fltk::idle();
+    in_idle = 0;
+  }
+  if (nfds) {
+    // For _WIN32 we need to poll for socket input FIRST, since
+    // the event queue is not something we can select() on...
     timeval t;
     t.tv_sec = 0;
-    t.tv_usec = 0;
-
-    fd_set fdt[3];
-    fdt[0] = fdsets[0];
-    fdt[1] = fdsets[1];
-    fdt[2] = fdsets[2];
-
-    if (::select(0,&fdt[0],&fdt[1],&fdt[2],&t)) {
-      // We got something - do the callback!
-      for (int i = 0; i < nfds; i ++) {
+    t.tv_usec = 0;
+    fd_set fdt[3];
+    memcpy(fdt, fdsets, sizeof fdt); // one shot faster fdt init
+    if (::select(maxfd+1,&fdt[0],&fdt[1],&fdt[2],&t)) {
+      // We got something - do the callback!
+      for (int i = 0; i < nfds; i ++) {
 	int f = fd[i].fd;
@@ -420,9 +414,10 @@
       // we need to check them periodically, so set a short timeout:
-      if (time_to_wait > .001) time_to_wait = .001;
-    }
-  }
-#endif // USE_ASYNC_SELECT
-
-  if (!fl_ready()) {
-    fl_unlock_function();
+      if (time_to_wait > .001) time_to_wait = .001;
+    }
+  }
+
+  if (fltk::idle || fltk::damage())
+    time_to_wait = 0.0;
+  if (!fl_ready()) {
+    fl_unlock_function();
     int t_msec =
@@ -435,19 +430,8 @@
   // Execute all pending messages:
-  int ret = 0;
-  while (__PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) > 0) {
-    ret++;
-#ifdef USE_ASYNC_SELECT
-    if (msg.message == WM_FLSELECT) {
-      // Got notification for socket
-      for (int i = 0; i < nfds; i ++)
-	if (fd[i].fd == (int)msg.wParam) {
-	  (fd[i].cb)(fd[i].fd, fd[i].arg);
-	  break;
-	}
-      // looks like it is best to do the dispatch-message anyway:
-    } else
-#endif
-    if (msg.message == WM_MAKEWAITRETURN) {
-      // save any data from fltk::awake() call:
-      if (msg.wParam) thread_message_ = (void*)msg.wParam;
+  int ret = 0;
+  while (__PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) > 0) {
+    ret++;
+    if (msg.message == WM_MAKEWAITRETURN) {
+      // save any data from fltk::awake() call:
+      if (msg.wParam) thread_message_ = (void*)msg.wParam;
       // WM_MAKEWAITRETURN is used by WndProc to try to make wait()
@@ -461,8 +445,8 @@
       TranslateMessage(&msg);
-      __DispatchMessage(&msg);
-    }
-  }
-
-  // This should return 0 for timeout, positive for events, and
-  // negative for errors.
+      __DispatchMessage(&msg);
+    }
+  }
+  fltk::flush();
+  // This should return 0 for timeout, positive for events, and
+  // negative for errors.
   // ret_val is probably useful, what is in it?
